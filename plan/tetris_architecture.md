# 테트리스 아키텍처 설계
버전: 1.0  
작성: 아키텍처 길드  
최종 업데이트: 2025-06-12

---

## 1. 아키텍처 목표
1. 도메인 로직을 프레임워크 및 디바이스로부터 분리하는 **클린 아키텍처** 준수  
2. 하나의 코어 코드로 **멀티 플랫폼(브라우저·Electron)** 배포 지원  
3. 코어를 수정하지 않고도 **플러그인·새 게임 모드·AI** 등을 추가할 수 있는 명확한 확장 지점 제공  
4. **테스트 용이성**(도메인/엔진 커버리지 ≥90 %)과 **유지보수성**(낮은 결합도·높은 응집도) 확보  

---

## 2. 레이어 구조 개요
```
-----------------------------------------------------------+
| 표현 계층 (UI)                                            |
|  • React / PixiJS 컴포넌트                                |
|  • 씬 그래프, 애니메이션, 입력 어댑터                    |
-------------------------+---------------------------------+
                          | 상태/셀렉터, 이벤트
-------------------------v---------------------------------+
| 애플리케이션 계층 (엔진)                                  |
|  • 고정 스텝 GameLoop                                     |
|  • Redux 스토어 & 슬라이스(보드, 피스, 점수, 설정)        |
|  • 순수 리듀서를 통해 도메인 규칙 오케스트레이션          |
-----------+------------+----------------------------------+
            | 호출
-----------v------------+----------------------------------+
| 도메인 계층                                             |
|  • 엔티티: Tetromino, Board, RandomBag                  |
|  • 유스케이스: RotatePiece, LockPiece, ClearLines       |
|  • 순수 FP / OOP, 프레임워크 독립                       |
-----------+------------+----------------------------------+
            | 인터페이스
-----------v------------+----------------------------------+
| 인프라 계층                                             |
|  • 저장 어댑터(localStorage / 파일 시스템)               |
|  • 오디오 어댑터(WebAudio / 네이티브)                    |
|  • 플랫폼 서비스(Electron IPC, 브라우저 API)             |
-----------------------------------------------------------+
```
화살표는 *컴파일 타임* 의존 방향(아래)이며, 런타임에서 바깥 레이어는 인터페이스를 통해서만 안쪽 레이어에 의존한다(Dependency Rule).

---

## 3. 컴포넌트 상호작용

### 3.1 시퀀스: 피스 고정 및 라인 클리어
```
 UI KeyDown
   |
   v
InputAdapter  --Dispatch-->  Redux Action (moveLeft)
                                |
                                v
                           Reducer (Domain fn)
                                |
                                v
                          New State emitted
                                |
        +-----------------------+-----------------------+
        |                                               |
 Renderer.subscribe()                           AudioService.listener()
   drawBoard()                                        playSFX()
```
1. `InputAdapter`가 DOM 이벤트를 도메인 의도 액션으로 매핑  
2. `boardSlice.reducer`가 순수 도메인 함수(`Board.canMove`, `Board.merge`) 호출 → 새 상태 생성  
3. **부수효과 없는** 리듀서는 결정론적 리플레이와 테스트를 가능하게 함  
4. UI·인프라 옵저버가 셀렉터 또는 RTK 리스너 미들웨어로 상태 변화에 반응  
5. 렌더러는 보드를 다시 그리고 오디오 서비스는 SFX를 재생  

### 3.2 게임 루프 타이밍
```
requestAnimationFrame
        |
        v (delta)
 GameLoop.accumulate()
   while (acc >= FIXED_DT) {
       store.dispatch(tick())
       acc -= FIXED_DT
   }
 Renderer.render(store.getState())
```
고정 스텝 루프는 하드웨어와 무관하게 동일한 게임 속도를 보장한다.

---

## 4. 데이터 흐름
1. **의도**(키보드, 메뉴)  
2. `Redux Action` 전송  
3. **리듀서** → 순수 도메인 로직 → **새 스토어 상태**  
4. **셀렉터**로 뷰 모델 파생  
5. **렌더러**가 캔버스 그리기  
6. **이펙트** 실행: 오디오·저장·분석 등 → 리스너 미들웨어/Thunk 에서 처리하여 리듀서 순수성 유지  

```
Intent -> Action -> Reducer -> State -> Selector -> View
                          ^                      |
                          |<-----Effect----------+
```

---

## 5. 상태 관리
| 슬라이스            | 책임                                   | 영속성 |
|--------------------|---------------------------------------|---------|
| `boardSlice`       | 그리드 셀, 활성/고스트 피스            | 휘발성  |
| `pieceSlice`       | 홀드, 넥스트 큐, 랜덤 시드             | 휘발성  |
| `scoreSlice`       | 점수, 라인 수, 레벨 속도               | 휘발성  |
| `settingsSlice`    | 키 바인딩, 볼륨, 테마                  | 영속    |
| `uiSlice`          | 메뉴, 모달, 포커스 상태                | 휘발성  |

`settingsSlice`는 플랫폼별 저장 어댑터가 직렬화한다.  
• 브라우저: `localStorage` JSON  
• 데스크톱: Electron IPC → `appData/settings.json`

---

## 6. 확장 전략
1. **플러그인 미들웨어**  
   - 액션(`onLineClear`, `onGameOver`)을 가로채 업적·분석·테마 등 부가기능 주입  
2. **기능 모듈**  
   - 새 모드(무한·대전)를 리듀서·UI 라우트로 추가, 도메인 불변  
3. **테마 시스템**  
   - 렌더러가 외부 JSON 팔레트를 로드하여 런타임 색상 오버라이드  
4. **AI 봇**  
   - 상태 구독→최적 수 계산→가상 액션 발행, 엔진 수정 없음  
5. **크로스 플랫폼 포팅**  
   - 표현/인프라 계층을 React Native + Canvas 등으로 교체해도 도메인·애플리케이션 재사용  

---

## 7. 품질 및 테스트 전략
- **도메인 테스트**: 순수 함수, 결정론적(모킹 없음)  
- **애플리케이션 테스트**: 스토어에 액션 시퀀스 디스패치 → 상태 전이 검증  
- **UI 테스트**: Playwright로 캔버스 스냅샷 비교  
- **계약 테스트**: 인프라 어댑터가 `StoragePort` 인터페이스 충족 여부 검증  
- **성능 벤치마크**: 저사양 GPU에서 평균 프레임 ≤ 16 ms 확인  
- **CI 게이트**: 커버리지 ≥ 90 %, 린트·타입체크·E2E 통과 시만 병합  

---

## 8. 아키텍처 위험 및 완화
| 위험                                   | 대응 전략                                        |
|---------------------------------------|--------------------------------------------------|
| UI ↔ 로직 강결합                       | 타입이 정의된 액션·셀렉터만으로 상호작용          |
| 대형 캔버스 성능 저하                 | 드로우 콜 배치, 객체 풀링, 필요 시 DOM 폴백      |
| 플랫폼별 기능 차이                    | 플랫폼 추상층을 얇게 유지, 계약 테스트 수행       |

---

## 9. 향후 진화 방향
- 멀티플레이 등 엔티티 복잡도 증가 시 **ECS** 도입 검토  
- 도메인 로직 WebAssembly 포팅 → C++/Rust AI 연구 지원  
- **서버 권한 레이어** 추가(실시간 대전, v1.2 로드맵)  

---

_문서 끝_
